var postListCtrl = function ($scope, $http, $attrs) {
  $scope.post         = null;
  $scope.posts        = []
  $scope.noMoreData   = false;
  $scope.usernames    = angular.fromJson( $attrs.usernames );

  $scope.loadPost = function() {
    $scope.dataLoading  = true;
    $scope.errorMessage = false;

    var promise = $http({
      url: $attrs.postPath + ".json",
      method: "GET"
    });
    promise = promise.then(function(response) {
      $scope.post         = response.data;
      $scope.errorMessage = false;
    }, function(response) {
      $scope.errorMessage = true;
    })
    promise.finally(function(response) {
      $scope.dataLoading  = false;
    });
  }

  $scope.loadMoreMessages = function() {
    var offset = $scope.posts.length;
    $scope.dataLoading  = true;
    $scope.errorMessage = false;

    var promise = $http({
      url: $attrs.postsPath + ".json",
      method: "GET",
      params: {"offset": offset, "limit": 20}
    });
    promise = promise.then(function(response) {
      if (response.data.posts.length === 0)
        $scope.noMoreData = true;

      $scope.posts = $scope.posts.concat(response.data.posts);
      $scope.errorMessage = false;
    }, function(response) {
      $scope.errorMessage = true;
    })
    promise.finally(function(response) {
      $scope.dataLoading  = false;
    });
  }

  if ($attrs.postPath)
    $scope.loadPost()
  else
    $scope.loadMoreMessages();

  $scope.createPost = function(post) {
    // Disable the submit button for new-post directive.
    $scope.submitButtonDisabled = true;

    post["compressed_photo"] = $(".compressed_photo").val();
    post["neighborhood_id"] = $attrs.neighborhoodId;
    var ajax = $http.post("/api/v0/posts/", {"post": post});
    ajax.success(function(data) {
      post.content = ""
      $(".preview").parent().html("<img class='preview'>")
      $(".compressed_photo").val("")
      $scope.submitButtonDisabled = false;
      $scope.posts.unshift(data)
    })

    ajax.error(function(data) {
      $scope.submitButtonDisabled = false;
    })
  }

  $scope.createComment = function(post, comment) {
    // Disable the submit button for new-post directive.
    $scope.submitButtonCommentDisabled = true;

    var ajax = $http.post("/api/v0/posts/" + post.id + "/comments", {"comment": comment});
    ajax.success(function(data) {
      comment.content = ""
      // $scope.submitButtonCommentDisabled = false;
      post.comments.push(data)
    })

    ajax.error(function(data) {
      // $scope.submitButtonCommentDisabled = false;
    })
  }


  // TODO: This is a bit confusing as it triggers the file upload, which has
  // an attribute directive defined on change event. Confusing code!
  $scope.triggerFileInput = function() {
    $("input[type='file']").trigger("click")
  }

  $scope.updateLikesCounter = function(post) {
    var ajax = $http.post(post.actions.like, {"count": post.likes_count});
    ajax.success(function(data) {
      post.likes_count = data.count;
      post.liked       = data.liked;
    })
  }

  $scope.updateCommentLikesCounter = function(comment) {
    // TODO: Use Rails routes.
    var ajax = $http.post("/api/v0/comments/" + comment.id + "/like", {"count": comment.likes_count});
    ajax.success(function(data) {
      comment.likes_count = data.count;
      comment.liked       = data.liked;
    })
  }
};

var newPostDirective = function(){
  return {
    restrict: "E", // Restrict the template to being called only when using <feed-item> HTML element.
    templateUrl: "<%= asset_path('posts/new.html') %>",
    link: function(scope, element, attrs) {
      scope.submitButtonDisabled = false;

      angular.element(element).find("textarea").atwho({
        at: "@",
        data: scope.usernames,
        limit: 5
      })
    }
  }
}

var newPostCustomDirective = function(){
  return {
    restrict: "E", // Restrict the template to being called only when using <feed-item> HTML element.
    templateUrl: "<%= asset_path('posts/new_custom.html') %>",
    link: function(scope, element, attrs) {
      scope.submitButtonDisabled = false;

      angular.element(element).find("textarea").atwho({
        at: "@",
        data: scope.usernames,
        limit: 5
      })
    }
  }
}


var newCommentDirective = function(){
  return {
    restrict: "E", // Restrict the template to being called only when using <feed-item> HTML element.
    templateUrl: "<%= asset_path('comments/new.html') %>",
    link: function(scope, element, attrs) {
      scope.submitButtonCommentDisabled = false;

      angular.element(element).find("textarea").atwho({
        at: "@",
        data: scope.usernames,
        limit: 5
      })
    }
  }
}

// NOTE: We're not specifying isolate scope here since we'll *ONLY* use this
// directive on the PostListCtrl. As such, we will use 'post' and all other
// methods from the parent scope (e.g. the controller). If we ever introduce
// scope here, we have to make sure that the ng-click events bubble up to the
// parent scope.
var feedItemDirective = function(){
  return {
    restrict: "E", // Restrict the template to being called only when using <feed-item> HTML element.
    templateUrl: "<%= asset_path('posts/show.html') %>"
  }
}

// NOTE: We're not specifying isolate scope here since we'll *ONLY* use this
// directive on the PostListCtrl. As such, we will use 'post' and all other
// methods from the parent scope (e.g. the controller). If we ever introduce
// scope here, we have to make sure that the ng-click events bubble up to the
// parent scope.
var feedItemNewDirective = function(){
  return {
    restrict: "E", // Restrict the template to being called only when using <feed-item> HTML element.
    templateUrl: "<%= asset_path('posts/show_new.html') %>"
  }
}


var commentDirective = function () {
  return {
    restrict: "E", // Restrict the template to being called only when using <post-comment> HTML element.
    // NOTE: We're not specifying isolate scope here since we'll *ONLY* use this
    // directive on the PostListCtrl. As such, we will use 'post' and all other
    // methods from the parent scope (e.g. the controller). If we ever introduce
    // scope here, we have to make sure that the ng-click events bubble up to the
    // parent scope.
    // scope: {
    //   "comment": "=" // This is equivalent to the "=comment" scope.
    // },
    templateUrl: "<%= asset_path('comments/show.html') %>"
  }
};


var commentNewDirective = function () {
  return {
    restrict: "E", // Restrict the template to being called only when using <post-comment> HTML element.
    // NOTE: We're not specifying isolate scope here since we'll *ONLY* use this
    // directive on the PostListCtrl. As such, we will use 'post' and all other
    // methods from the parent scope (e.g. the controller). If we ever introduce
    // scope here, we have to make sure that the ng-click events bubble up to the
    // parent scope.
    // scope: {
    //   "comment": "=" // This is equivalent to the "=comment" scope.
    // },
    templateUrl: "<%= asset_path('comments/show_new.html') %>"
  }
};

var fileUploadDirective = function() {
  return {
    restrict: 'A',
    link: function (scope, element, attr) {
      element.bind('change', function (event) {
        window.compression.compressFileFromHTMLInput(event.target);
      });
    }
  }
}

// We use inline annotation to declare services in order to bypass
// errors when JS gets minified:
// https://docs.angularjs.org/tutorial/step_05
var postController = angular.module('dengueChatApp');
postController.controller("DCPostListCtrl", ["$scope", "$http", "$attrs", postListCtrl]);


// Define the directives on the controller.
postController.directive("postComment", commentDirective);
postController.directive("postCommentNew", commentNewDirective);
postController.directive("feedItem", feedItemDirective);
postController.directive("feedItemNew", feedItemNewDirective);
postController.directive("newPost", newPostDirective);
postController.directive("newPostCustom", newPostCustomDirective);
postController.directive("fileUpload", fileUploadDirective);
postController.directive("newComment", newCommentDirective);




// TODO: Refactor this into its own directive.
window.compression = {}
window.compression.compressFileFromHTMLInput = function(element) {
  window.test = element;
  var canvas     = $(element).parent().find("canvas")[0];
  var preview    = $(element).parent().find(".preview");
  var file       = element.files[0];
  var compressedHTMLInput = $(element).parent().find(".compressed_photo")

  if (!file.type.match('image.*'))
    return;

  var reader = new FileReader();
  reader.onload = (function(file) {
    return function(e) {
      var image = new Image();
      image.src = e.target.result;

      image.onload = function () {
        var compressedImage = compressImageOntoCanvas(image, canvas)
        $(preview).attr({src: compressedImage, title: escape(file.name)});
        $(element).val("");
        $(compressedHTMLInput).val(compressedImage)
      };
    };
  })(file);

  reader.readAsDataURL(file);
}


compressImageOntoCanvas = function(image, canvas) {
  var width  = image.width;
  var height = image.height;
  var maxWidth  = 517;
  var maxHeight = 600;

  if (width > height) {
    if (width > maxWidth) {
      height *= maxWidth / width;
      width = maxWidth;
    }
  }
  else {
    if (height > maxHeight) {
      width *= maxHeight / height;
      height = maxHeight;
    }
  }

  // Draw the canvas image with new dimensions, and append.
  canvas.height = height;
  canvas.width  = width;
  var ctx = canvas.getContext("2d");
  ctx.drawImage(image, 0, 0, width, height);

  // NOTE: We're using 0.75 JPEG quality per this article:
  // http://www.html5rocks.com/en/tutorials/speed/img-compression/
  return canvas.toDataURL("image/jpeg", 1.0);
}
